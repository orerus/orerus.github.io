<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 1</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
    <link rel=”shortcut icon” href=”favicon.ico” />
</head>
<body>

<script type="text/javascript">
function getUrlQueries() {
  var queryStr = window.location.search.slice(1);  // 文頭?を除外
      queries = {};

  // クエリがない場合は空のオブジェクトを返す
  if (!queryStr) {
    return queries;
  }

  // クエリ文字列を & で分割して処理
  queryStr.split('&').forEach(function(queryStr) {
    // = で分割してkey,valueをオブジェクトに格納
    var queryArr = queryStr.split('=');
    queries[queryArr[0]] = queryArr[1];
  });

  return queries;
}
var queries = getUrlQueries();
/// Gameパラメーター /////////////////
// 自キャラ設定 ///////////////////////////////
// playerSpeed:         0 <= speed <= 1000  スピード
var playerSpeed = 300;
// 敵キャラ当たり判定設定 ///////////////////////
var hitRangeX = queries.hitRangeX ? Number(queries.hitRangeX) : 50; // x座標のズレがこの値より小さければ当たり判定
var hitRangeY = queries.hitRangeY ? Number(queries.hitRangeY) : 20; // y座標のズレがこの値より小さければ当たり判定
var hitSneezeRangeX = queries.hitSneezeRangeX ? Number(queries.hitSneezeRangeX) : 200; // くしゃみをした時のx座標当たり判定（前方）
var hitSneezeRangeY = queries.hitSneezeRangeY ? Number(queries.hitSneezeRangeY) : 250; // くしゃみをした時のx座標当たり判定
// 敵キャラ設定 ///////////////////////////////
// isCorona:    true/false          コロナかどうか
// x:           200 <= x <= 3000    初期x座標 
// y:           430 <= y <= 600     初期y座標 (moveTypeが3の場合のみ反映)
// direction:   left/right          初期向き (moveTypeが3の場合のみ反映)
// speed:       0 <= speed <= 1000  スピード (300が初期値, moveTypeが3の場合のみ反映)
// moveType:    0, 1, 2, 3          0: 円, 1: 斜め, 2: 上下, 3: 左右
// sneezeRate:  0 <= sneezeRate <= 10000    くしゃみをする確率（0 ~ 30 くらいが適正。1フレームあたり sneezeRate/10000 の確率でくしゃみをする。）
// charaType:   a, b, c, d          敵の図柄タイプ
var enemyParameters = [
    {
        isCorona: true,
        x: 200,
        y: 430,
        direction: 'right',
        speed: 350,
        moveType: 3,
        sneezeRate: 80,
        charaType: 'a',
    },
    {
        isCorona: false,
        x: 1200,
        y: 450,
        direction: 'right',
        speed: 350,
        moveType: 3,
        sneezeRate: 80,
        charaType: 'b',
    },
    {
        isCorona: true,
        x: 2200,
        y: 450,
        direction: 'right',
        speed: 350,
        moveType: 3,
        sneezeRate: 0,
        charaType: 'c',
    },
    {
        isCorona: false,
        x: 250,
        y: 475,
        direction: 'right',
        speed: 300,
        moveType: 3,
        sneezeRate: 50,
        charaType: 'd',
    },
    {
        isCorona: false,
        x: 300,
        y: 500,
        direction: 'right',
        speed: 250,
        moveType: 3,
        sneezeRate: 50,
        charaType: 'a',
    },
    {
        isCorona: true,
        x: 350,
        y: 525,
        direction: 'left',
        speed: 200,
        moveType: 3,
        sneezeRate: 50,
        charaType: 'b',
    },
    {
        isCorona: false,
        x: 400,
        y: 550,
        direction: 'right',
        speed: 150,
        moveType: 3,
        sneezeRate: 10,
        charaType: 'c',
    },
    {
        isCorona: true,
        x: 450,
        y: 575,
        direction: 'left',
        speed: 100,
        moveType: 3,
        sneezeRate: 0,
        charaType: 'd',
    },
    {
        isCorona: true,
        x: 500,
        y: 600,
        direction: 'right',
        speed: 50,
        moveType: 3,
        sneezeRate: 10,
        charaType: 'a',
    },
];
// 環境設定 ///////////////////////////////
// isGameDebug:         デバッグモード
// wallAlpha:           0 <= speed <= 1  透過率
var isGameDebug = true;
var wallAlpha = isGameDebug ? 0.5 : 0.0;
////////////////////////////////////

function getRandomInt(max) {
  return Math.floor(Math.random() * Math.floor(max));
}

class LoaderScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'LoaderScene' });
    }

    preload ()
    {
        // ここで全ての必要なimageをloadする
        this.load.multiatlas('gamescene', 'assets/gamescene.json', 'assets');
        this.load.image('background', 'assets/background.png');
        this.load.image('bad_end', 'assets/end_bad.png');
        this.load.image('happy_end', 'assets/end_happy.png');
    }

    create ()
    {
        // console.log('From LoaderScene Create');
        this.scene.start('TitleScene');
    }

    update () {
        // this.scene.start('TitleScene');
    }
}

class TitleScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'TitleScene' });
    }

    preload ()
    {
        this.titleText = null;
        this.easyText = null;
        this.normalText = null;
        this.hardText = null;
        this.pointer = null;
        this.isDismissed = false;
    }

    create ()
    {
        this.isDismissed = false;
        this.titleText = this.add.text(400, 150, 'Title', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.easyText = this.add.text(400, 300, '↑： Easy', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.normalText = this.add.text(400, 400, '→： Normal', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);

        // Create the left/right arrow keys
        var up = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
        up.on('down', () => this.nextEasy());
        var right = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
        right.on('down', () => this.nextNormal());
    }

    update () {
        this.pointer = this.input.activePointer;
        // pointerがモードを選択しているかどうか
        if (this.pointer.isDown && !this.isDismissed) {
            let x = this.pointer.x;
            let y = this.pointer.y;
            console.log(`Pointer ${this.pointer.x} ${this.pointer.y}`);
            if (Math.abs(this.easyText.x - x) < this.easyText.displayWidth / 2 && Math.abs(this.easyText.y - y) < this.easyText.displayHeight / 2) {
                this.isDismissed = true;
                this.nextEasy();
            } else if (Math.abs(this.normalText.x - x) < this.normalText.displayWidth / 2 && Math.abs(this.normalText.y - y) < this.normalText.displayHeight / 2) {
                this.isDismissed = true;
                this.nextNormal();
            }
        }

        // this.text.setText([
        //     'x: ' + this.pointer.x,
        //     'y: ' + this.pointer.y,
        //     'mid x: ' + this.pointer.midPoint.x,
        //     'mid y: ' + this.pointer.midPoint.y,
        //     'velocity x: ' + this.pointer.velocity.x,
        //     'velocity y: ' + this.pointer.velocity.y,
        //     'movementX: ' + this.pointer.movementX,
        //     'movementY: ' + this.pointer.movementY,
        //     'isDown:' + this.pointer.isDown
        // ]);
    }

    // gameMode 0: easy, 1: normal
    nextEasy() {
        this.physics.pause();
        this.scene.start('GameScene', {gameMode: 0});
    }
    nextNormal() {
        this.physics.pause();
        this.scene.start('GameScene', {gameMode: 1});
    }
}

class GameScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'GameScene' });
    }

    preload ()
    {
        this.own = {};
        this.own.time = null;
        this.own.isEasy = false;
        this.own.enemies = {};
        this.own.move = 90 * (Math.PI / 180);
        this.own.playerHeight = 324;
        this.own.worldMinX = 0;
        this.own.worldMaxX = 800;
        this.own.worldMinY = 430 - this.own.playerHeight;
        this.own.worldMaxY = 600; //+ this.own.playerHeight;
        this.own.enemyInitY = (this.own.worldMaxY + this.own.worldMinY + this.own.playerHeight) / 2 ;
        this.own.worldDistanceY = this.own.worldMaxY - this.own.worldMinY - this.own.playerHeight;
        this.own.worldHalfDistanceY = 55; //this.own.worldDistanceY / 2;
        this.own.cursors = null;
        this.own.player = null;
        this.own.playerSpeed = playerSpeed;
        this.own.remainTime = 600; // 初期残り時間
        this.own.coronaPointText = null;
        this.own.remainText = null;
        this.own.coronaPoint = 0;
        this.own.pointerState = {};
        this.own.pointerState.isDowning = false;
        this.own.pointerState.startX = 0;
        this.own.pointerState.startY = 0;
        this.own.isGoalOpened = false;
        this.own.debug = true; // DEBUG MODE
        this.isDismissed = false;
    }

    create (data)
    {
        // this.events.once("shutdown", () => this.shutdown());
        // console.log('From GameScene Create');
        // TODO DEBUG
        if(this.own.debug) window.console.log('現在のゲームモード: ' + data.gameMode);
        this.own.isEasy = (data.gameMode === 0);

        this.cameras.main.setBounds(0, 0, 3600, 600);
        // this.physics.world.setBounds(worldMinX, worldMinY, worldMaxX, worldMaxY);
        this.physics.world.setBounds(this.own.worldMinX, this.own.worldMinY, this.own.worldMaxX * 4 + 400, this.own.worldMaxY - this.own.worldMinY);
        this.cameras.main.setDeadzone(100, 20);
        // this.cameras.main.setZoom(1.3);

        // 背景画像の設定
        let background = this.add.image(0, 0, 'background').setScale(1.2).setOrigin(0);

        // 主人公設定
        this.own.player = this.physics.add.sprite(0, 550, 'gamescene', 'chara/main_a1_4.png');
        this.own.player.setScale(0.8, 0.8);
        this.own.player.setCollideWorldBounds(true);
        this.cameras.main.startFollow(this.own.player, true);
        this.own.player.own = {};
        this.own.player.own.hasMask = false;
        this.own.player.own.hasWashed = false;

        // 壁の当たり判定
        let homeWall = this.add.rectangle(
            250,
            0, 
            10, 
            250, 
            0x333333
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(homeWall, true);
        let barTopWall = this.add.rectangle(
            3200,
            0, 
            500, 
            220, 
            0x333333
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(barTopWall, true);
        let barBottomWall = this.add.rectangle(
            3300,
            this.own.worldMaxY - 100, 
            500, 
            100, 
            0x333333
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(barBottomWall, true);
        this.physics.add.collider(this.own.player, homeWall);
        this.physics.add.collider(this.own.player, barTopWall);
        this.physics.add.collider(this.own.player, barBottomWall);

        // ゴールゾーン
        this.own.goalZone = this.add.rectangle(
            0,
            0, 
            100, 
            600, 
            0x0000ff
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(this.own.goalZone, true);
        this.physics.add.overlap(this.own.player, this.own.goalZone, () => this.hitGoal());
        // マスクゾーン
        let maskWall = this.add.rectangle(
            0,
            100, 
            200, 
            10, 
            0x008000
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(maskWall, true);
        this.physics.add.collider(this.own.player, maskWall, () => this.hitMask());
        // 手洗いゾーン
        let washWall = this.add.rectangle(
            260,
            0, 
            1, 
            150, 
            0x008000
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(washWall, true);
        this.physics.add.collider(this.own.player, washWall, () => this.hitWash());
        // Barゾーン
        let barWall = this.add.rectangle(
            3410,
            0, 
            10, 
            600, 
            0x008000
        ).setAlpha(wallAlpha).setOrigin(0);
        this.physics.add.existing(barWall, true);
        this.physics.add.collider(this.own.player, barWall, () => this.hitDrinking());

        // Bar内の人物
        let woman = this.add.sprite(3535, 475, 'gamescene', 'chara/teki_d1_4.png').setScale(0.8);
        woman.flipX = true;
        let man = this.add.sprite(3525, 610, 'gamescene', 'chara/teki_f_b1.png').setScale(0.8);

        // 敵の初期配置
        for (var i = 0; i < enemyParameters.length; i++) {
            let enemyInitX = enemyParameters[i].x; //1600 + (getRandomInt(57) - 28) * 25;
            // var randomEnemyInitY = this.own.enemyInitY + getRandomInt(this.own.worldDistanceY) - this.own.worldHalfDistanceY;
            let enemyInitY = enemyParameters[i].y;
            if (enemyParameters[i].moveType < 3) enemyInitY = this.own.enemyInitY; //this.own.worldMinY + this.own.playerHeight;
            this.own.enemies[i] = this.physics.add.sprite(enemyInitX, enemyInitY, 'gamescene', `chara/teki_${enemyParameters[i].charaType}1_4.png`);
            this.own.enemies[i].own = {};
            this.own.enemies[i].own.speed = enemyParameters[i].speed;
            this.own.enemies[i].own.moveType = enemyParameters[i].moveType;
            this.own.enemies[i].own.enemyInitX = enemyInitX;
            this.own.enemies[i].own.isCorona = enemyParameters[i].isCorona;
            this.own.enemies[i].own.charaType = enemyParameters[i].charaType;
            this.own.enemies[i].own.isInfected = false;
            this.own.enemies[i].own.sneezeRate = enemyParameters[i].sneezeRate;
            this.own.enemies[i].own.sneezeRemainTime = 0;
            this.own.enemies[i].setScale(0.8, 0.8);
            this.own.enemies[i].flipX = enemyParameters[i].direction === 'left';
        }

        // アニメーション生成
        var setDrinkingFrameNames = this.anims.generateFrameNames('gamescene', {
            start: 1, end: 2, zeroPad: 1,
            prefix: 'chara/main_a5_', suffix: '.png'
        });
        this.anims.create({ key: 'setDrinking', frames: setDrinkingFrameNames, frameRate: 10, repeat: 8 });
        var setWashedFrameNames = this.anims.generateFrameNames('gamescene', {
            start: 1, end: 2, zeroPad: 1,
            prefix: 'chara/main_a4_', suffix: '.png'
        });
        this.anims.create({ key: 'setWashed', frames: setWashedFrameNames, frameRate: 10, repeat: 8 });
        var setWashedWithMaskFrameNames = this.anims.generateFrameNames('gamescene', {
            start: 3, end: 4, zeroPad: 1,
            prefix: 'chara/main_a4_', suffix: '.png'
        });
        this.anims.create({ key: 'setWashedWithMask', frames: setWashedWithMaskFrameNames, frameRate: 10, repeat: 8 });
        var setMaskFrameNames = this.anims.generateFrameNames('gamescene', {
            start: 1, end: 8, zeroPad: 1,
            prefix: 'chara/main_a3_', suffix: '.png'
        });
        this.anims.create({ key: 'setMask', frames: setMaskFrameNames, frameRate: 10, repeat: 1 });
        this.anims.create({ key: 'maskWalk', frames: setMaskFrameNames, frameRate: 10, repeat: -1 });
        var maskStayframeNames = this.anims.generateFrameNames('gamescene', {
            start: 4, end: 4, zeroPad: 1,
            prefix: 'chara/main_a3_', suffix: '.png'
        });
        this.anims.create({ key: 'maskStay', frames: maskStayframeNames, frameRate: 10, repeat: -1 });

        var walkframeNames = this.anims.generateFrameNames('gamescene', {
            start: 1, end: 8, zeroPad: 1,
            prefix: 'chara/main_a1_', suffix: '.png'
        });
        this.anims.create({ key: 'walk', frames: walkframeNames, frameRate: 10, repeat: -1 });
        var stayframeNames = this.anims.generateFrameNames('gamescene', {
            start: 4, end: 4, zeroPad: 1,
            prefix: 'chara/main_a1_', suffix: '.png'
        });
        this.anims.create({ key: 'stay', frames: stayframeNames, frameRate: 10, repeat: -1 });
        this.makeWalkFrameNames(this, 'a1');
        this.makeWalkFrameNames(this, 'a2');
        this.makeWalkFrameNames(this, 'b1');
        this.makeWalkFrameNames(this, 'b2');
        this.makeWalkFrameNames(this, 'c1');
        this.makeWalkFrameNames(this, 'c2');
        this.makeWalkFrameNames(this, 'd1');
        this.makeWalkFrameNames(this, 'd2');
        this.makeStayFrameNames(this, 'a1');
        this.makeStayFrameNames(this, 'a2');
        this.makeStayFrameNames(this, 'b1');
        this.makeStayFrameNames(this, 'b2');
        this.makeStayFrameNames(this, 'c1');
        this.makeStayFrameNames(this, 'c2');
        this.makeStayFrameNames(this, 'd1');
        this.makeStayFrameNames(this, 'd2');
        this.makeSneezeFrameNames(this, 'a', 1);
        this.makeSneezeFrameNames(this, 'a', 2);
        this.makeSneezeFrameNames(this, 'b', 1);
        this.makeSneezeFrameNames(this, 'b', 2);
        this.makeSneezeFrameNames(this, 'c', 1);
        this.makeSneezeFrameNames(this, 'c', 2);
        this.makeSneezeFrameNames(this, 'd', 1);
        this.makeSneezeFrameNames(this, 'd', 2);

        this.own.cursors = this.input.keyboard.createCursorKeys();
        // テキスト配置
        if (this.own.debug) {
            this.own.coronaPointText = this.add.text(32, 32).setScrollFactor(0).setFontSize(32).setColor('#000000');
            this.own.coronaPointText.setText('CoronaPoint: ' + this.own.coronaPoint);
        }
        this.own.remainText = this.add.text(600, 32).setScrollFactor(0).setFontSize(32).setColor('#000000');
        this.own.remainText.setText('Time: ' + this.own.remainTime);
    }

    makeWalkFrameNames(context, pattern) {
        let frames = context.anims.generateFrameNames('gamescene', {
            start: 1, end: 8, zeroPad: 1,
            prefix: `chara/teki_${pattern}_`, suffix: '.png'
        });
        context.anims.create({ key: 'enemyWalk' + pattern, frames: frames, frameRate: 10, repeat: -1 });
        console.log('enemyWalk' + pattern);
    }

    makeStayFrameNames(context, pattern) {
        let frames = context.anims.generateFrameNames('gamescene', {
            start: 4, end: 4, zeroPad: 1,
            prefix: `chara/teki_${pattern}_`, suffix: '.png'
        });
        context.anims.create({ key: 'enemyStay' + pattern, frames: frames, frameRate: 10, repeat: -1 });
        console.log('enemyStay' + pattern);
    }

    makeSneezeFrameNames(context, pattern, coronaPattern) { // coronaPattern: 1, 2
        let startFrame = coronaPattern === 2 ? 3 : 1;
        let frames = context.anims.generateFrameNames('gamescene', {
            start: startFrame, end: startFrame + 1, zeroPad: 1,
            prefix: `chara/teki_e_${pattern}`, suffix: '.png'
        });
        context.anims.create({ key: 'enemySneeze' + pattern + coronaPattern, frames: frames, frameRate: 10, repeat: -1 });
        console.log('enemySneeze' + pattern + coronaPattern);
    }

    update (time, delta) {
        // console.log('From GameScene Update');
        // スワイプの動き（スマホ用）
        let pointer = this.input.activePointer;
        if (pointer.isDown && !this.own.pointerState.isDowning) {
            this.own.pointerState.isDowning = true;
            this.own.pointerState.startX = pointer.x;
            this.own.pointerState.startY = pointer.y;
        }
        if (!pointer.isDown) this.own.pointerState.isDowning = false;
        let isLeftDown = pointer.isDown && pointer.x < this.own.pointerState.startX - 50;
        let isRightDown = pointer.isDown && pointer.x > this.own.pointerState.startX + 50;
        let isUpDown = pointer.isDown && pointer.y < this.own.pointerState.startY - 50;
        let isDownDown = pointer.isDown && pointer.y > this.own.pointerState.startY + 50;

        // プレイヤー処理
        this.own.player.setVelocity(0);
        if (!this.own.player.own.isStop) {
            // カーソル
            if (this.own.cursors.left.isDown || isLeftDown)
            {
                this.own.player.setVelocityX(-this.own.playerSpeed);
                this.own.player.flipX = true;
                // this.own.player.anims.play('walk', true);
            }
            if (this.own.cursors.right.isDown || isRightDown)
            {
                this.own.player.setVelocityX(this.own.playerSpeed);
                this.own.player.flipX = false;
                // this.own.player.anims.play('walk', true);
            }
            if (this.own.cursors.up.isDown || isUpDown)
            {
                this.own.player.setVelocityY(-this.own.playerSpeed);
                // this.own.player.anims.play('walk', true);
            }
            if (this.own.cursors.down.isDown || isDownDown)
            {
                this.own.player.setVelocityY(this.own.playerSpeed);
                // this.own.player.anims.play('walk', true);
            }
            if ((!this.own.cursors.left.isDown && !this.own.cursors.right.isDown && !this.own.cursors.up.isDown && !this.own.cursors.down.isDown) && !(isLeftDown || isRightDown || isUpDown || isDownDown)) {
                this.own.player.anims.play(this.own.player.own.hasMask ? 'maskStay' : 'stay', true);
            } else {
                this.own.player.anims.play(this.own.player.own.hasMask ? 'maskWalk' : 'walk', true);
            }
        }
        // depth sorting
        this.own.player.depth = this.own.player.y;

        // enemy
        for (var i = 0; i < enemyParameters.length; i++) {
            this.own.enemies[i].setVelocity(0);
            let coronaPattern = this.own.isEasy ? (this.own.enemies[i].own.isCorona ? 2 : 1) : 1;
            if (this.own.enemies[i].own.sneezeRemainTime <= 0) { // 敵キャラくしゃみ中は動かない
                switch (this.own.enemies[i].own.moveType) {
                case 0:
                    this.own.enemies[i].setVelocityX(Math.cos(this.own.move) * this.own.worldHalfDistanceY);
                    // this.own.enemies[i].x = this.own.enemyInitY + Math.cos(this.own.move) * this.own.worldHalfDistanceY;
                    this.own.enemies[i].setVelocityY(Math.sin(this.own.move) * this.own.worldHalfDistanceY);
                    // console.log(Math.sin(this.own.move))
                    // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.sin(this.own.move) * this.own.worldHalfDistanceY;
                    break;
                case 1:
                    this.own.enemies[i].setVelocityX(Math.sin(-this.own.move) * this.own.worldHalfDistanceY);
                    // this.own.enemies[i].x = this.own.enemyInitY + Math.sin(-this.own.move) * this.own.worldHalfDistanceY;
                    this.own.enemies[i].setVelocityY(Math.cos(-this.own.move) * this.own.worldHalfDistanceY);
                    // console.log(Math.cos(-this.own.move))
                    // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.cos(-this.own.move) * this.own.worldHalfDistanceY;
                case 2:
                    this.own.enemies[i].setVelocityY(Math.sin(this.own.move) * (this.own.worldHalfDistanceY));
                    // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.sin(this.own.move) * (this.own.worldHalfDistanceY - 20);
                    break;
                case 3:
                    if (this.own.enemies[i].flipX) {
                        // 左向き
                        if (this.own.enemies[i].x > 800) {
                            this.own.enemies[i].setVelocityX(-this.own.enemies[i].own.speed);
                        } else {
                            this.own.enemies[i].setVelocityX(this.own.enemies[i].own.speed);
                        }
                    } else {
                        // 右向き
                        if (this.own.enemies[i].x < 3000) {
                            this.own.enemies[i].setVelocityX(this.own.enemies[i].own.speed);
                        } else {
                            this.own.enemies[i].setVelocityX(-this.own.enemies[i].own.speed);
                        }
                    }
                    break;
                default:
                    console.log('Sorry, we are out of ' + i + '.');
                }

                // 敵キャラ振り向き判定
                if (this.own.enemies[i].body.velocity.x > 0) {
                    this.own.enemies[i].flipX = false
                } else if (this.own.enemies[i].body.velocity.x < 0) {
                    this.own.enemies[i].flipX = true
                }
                // 敵キャラアニメーション
                if (this.own.enemies[i].body.velocity.x === 0 && this.own.enemies[i].body.velocity.y === 0) {
                    this.own.enemies[i].anims.play(`enemyStay${this.own.enemies[i].own.charaType}${coronaPattern}`, true);
                } else {
                    console.log(`enemyWalk${this.own.enemies[i].own.charaType}${coronaPattern}`);
                    this.own.enemies[i].anims.play(`enemyWalk${this.own.enemies[i].own.charaType}${coronaPattern}`, true);
                }
                // 敵キャラdepth更新
                this.own.enemies[i].depth = this.own.enemies[i].y;
            }

            // playerとの当たり判定
            if (this.own.enemies[i].own.isCorona) {
                // 敵キャラ当たり判定
                if (!this.own.enemies[i].own.isInfected && Math.abs(this.own.enemies[i].x - this.own.player.x) <= hitRangeX && Math.abs(this.own.enemies[i].y - this.own.player.y) <= hitRangeY) {
                    this.own.enemies[i].own.isInfected = true;
                    this.own.coronaPoint += 1;
                }
                // 敵キャラくしゃみ当たり判定
                if (this.own.enemies[i].own.sneezeRemainTime > 0) {
                    // console.log(`Pothis.own.enemies[i] ${i} ${this.own.enemies[i].own.sneezeRemainTime} ${this.own.enemies[i].x} ${this.own.enemies[i].y} ${this.own.enemies[i].own.sneezeRange.x} ${this.own.enemies[i].own.sneezeRange.y}`)
                    this.own.enemies[i].own.sneezeRemainTime -= 1;
                    if (this.own.enemies[i].own.sneezeRange) {
                        if (!this.own.enemies[i].own.isInfected && this.own.enemies[i].own.sneezeRange.x <= this.own.player.x && this.own.player.x <= this.own.enemies[i].own.sneezeRange.x + this.own.enemies[i].own.sneezeRange.width && this.own.enemies[i].own.sneezeRange.y <= this.own.player.y && this.own.player.y <= this.own.enemies[i].own.sneezeRange.y + this.own.enemies[i].own.sneezeRange.height) {
                            this.own.enemies[i].own.isInfected = true;
                            this.own.coronaPoint += 1;
                        }
                    }
                    // くしゃみ時間がなくなったのでくしゃみ消す
                    if (this.own.enemies[i].own.sneezeRemainTime <= 0) {
                        if (this.own.enemies[i].own.sneezeRange) {
                            this.own.enemies[i].own.sneezeRange.destroy();
                            this.own.enemies[i].own.sneezeRange = null;
                        }
                    }
                }
                // 敵キャラがくしゃみをしていない時にランダムで行う
                if (this.own.enemies[i].own.sneezeRemainTime <= 0 && getRandomInt(10000) < this.own.enemies[i].own.sneezeRate) {
                    this.own.enemies[i].own.sneezeRemainTime = 100;
                    this.own.enemies[i].own.sneezeRange = this.add.rectangle(
                        this.own.enemies[i].flipX ? (this.own.enemies[i].x) - hitSneezeRangeX : this.own.enemies[i].x,
                        this.own.enemies[i].y - hitSneezeRangeY / 2, 
                        hitSneezeRangeX, 
                        hitSneezeRangeY, 
                        0x6666ff
                    ).setAlpha(this.own.isEasy ? 0.5 : 0.0).setOrigin(0);
                    this.own.enemies[i].anims.play(`enemySneeze${this.own.enemies[i].own.charaType}${coronaPattern}`, true);
                }
            }
        }

        // デバッグテキスト
        if (this.own.debug) {
            this.own.coronaPointText.setText('CoronaPoint: ' + this.own.coronaPoint);
        }

        // 残り時間判定
        if (this.own.remainTime > 0) {
            this.own.remainTime -= 1;
            this.own.remainText.setText('Time: ' + this.own.remainTime);
        }
        if (this.own.remainTime <= 0 && !this.own.isGoalOpened) {
            this.own.isGoalOpened = true;
        } 
        this.own.move += 0.01;
    }

    hitGoal() {
        console.log('get Goal!!!');
        if (!this.own.isGoalOpened) return; // Goal条件を満たしていないと何もしない
        if (this.isDismissed) return; // Goal済みなら何もしない
        this.isDismissed = true;
        // go to result
        this.physics.pause();
        this.scene.start('ResultScene', {coronaPoint: this.own.coronaPoint});
    }

    hitMask() {
        console.log('get Mask!!!');
        if (this.own.player.own.hasMask) return; // マスクを既に持っていれば何もしない
        this.own.player.own.hasMask = true;
        this.own.player.anims.play('setMask');
        this.own.player.own.isStop = true;
        this.own.coronaPoint -= 1;

        this.own.player.once('animationcomplete', this.setAnimComplete, this);
    }

    hitWash() {
        console.log('get Wash!!!');
        if (!this.own.player.own.hasWashed) {
            this.own.coronaPoint -= 1;
        } // 既に手洗いをしたことがあればポイントは減らさない
        this.own.player.own.hasWashed = true;
        this.own.player.anims.play(this.own.player.own.hasMask ? 'setWashedWithMask' : 'setWashed');
        this.own.player.own.isStop = true;

        this.own.player.once('animationcomplete', this.setAnimComplete, this);
    }

    hitDrinking() {
        console.log('get Drink!!!');
        if (!this.own.player.own.hasDrinking) {
            this.own.coronaPoint += 1;
        } // 既にBarに着いたことがあればポイントは増やさない
        this.own.player.own.hasDrinking = true;
        this.own.player.anims.play('setDrinking');
        this.own.player.own.isStop = true;
        this.own.isGoalOpened = true;

        this.own.player.once('animationcomplete', this.setAnimComplete, this);
    }

    setAnimComplete() {
        this.own.player.own.isStop = false;
    }

    // shutdown() {
    //     console.log('From GameScene shutdown');
    //     this.game.anims.removeAllListeners();
    // }
}

class ResultScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'ResultScene' });
    }

    preload ()
    {
        this.laterText = null;
        this.laterRemainTime = 150;
        this.laterBackground = null;
        this.resultText = null;
        this.retryText = null;
        this.coronaPoint = 0;
        this.isOpened = false;
        this.cursors = null;
        this.isDismissed = false;
    }

    create (data)
    {
        // console.log('From ResultScene Create');
        this.coronaPoint = data.coronaPoint;
        if (this.coronaPoint <= 0) {
            let background = this.add.image(400, 300, 'happy_end').setScale(1.1);
            this.resultText = this.add.text(400, 150, 'Happy end!', { fontSize: '72px', fill: '#000' }).setOrigin(0.5);
            this.retryText = this.add.text(400, 425, '→： Retry', { fontSize: '48px', fill: '#000' }).setOrigin(0.5);
        } else {
            let background = this.add.image(400, 300, 'bad_end').setScale(1.1);
            this.resultText = this.add.text(400, 150, 'Bad end…', { fontSize: '72px', fill: '#fff' }).setOrigin(0.5);
            this.retryText = this.add.text(400, 225, '→： Retry', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        }
        this.laterBackground = this.add.rectangle(0, 0, 800, 600, 0x000000).setOrigin(0);
        this.laterText = this.add.text(400, 150, '10 days later・・・', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.cursors = this.input.keyboard.createCursorKeys();
    }

    update () {
        // console.log('From ResultScene Update');
        if (this.isDismissed) return;
        if (!this.isOpened) {
            this.laterRemainTime -= 1;

            if (this.laterRemainTime <= 0) {
                this.isOpened = true;
                this.laterText.destroy();
                this.laterBackground.destroy();
            }
        } else {
            if (this.cursors.right.isDown)
            {
                this.nextTitle();
            }
            // スワイプの動き（スマホ用）
            let pointer = this.input.activePointer;
            if (pointer.isDown) {
                let x = pointer.x;
                let y = pointer.y;
                if (!this.isDismissed && Math.abs(this.retryText.x - x) < this.retryText.displayWidth / 2 && Math.abs(this.retryText.y - y) < this.retryText.displayHeight / 2) {
                    this.isDismissed = true;
                    this.nextTitle();
                }
            }
        }
    }

    nextTitle () {
        this.physics.pause();
        this.scene.start('TitleScene');
    }
}

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                // gravity: { y: 300 },
                debug: false
            }
        },
        scene: [ LoaderScene, TitleScene, GameScene, ResultScene ]
    };

    var game = new Phaser.Game(config);
</script>

</body>
</html>