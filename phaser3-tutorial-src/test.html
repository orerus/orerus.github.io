<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 1</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
    <link rel=”shortcut icon” href=”favicon.ico” />
</head>
<body>

<script type="text/javascript">
function getUrlQueries() {
  var queryStr = window.location.search.slice(1);  // 文頭?を除外
      queries = {};

  // クエリがない場合は空のオブジェクトを返す
  if (!queryStr) {
    return queries;
  }

  // クエリ文字列を & で分割して処理
  queryStr.split('&').forEach(function(queryStr) {
    // = で分割してkey,valueをオブジェクトに格納
    var queryArr = queryStr.split('=');
    queries[queryArr[0]] = queryArr[1];
  });

  return queries;
}
var queries = getUrlQueries();
/// Gameパラメーター /////////////////
// 敵キャラ当たり判定設定 ///////////////////////
var hitRangeX = queries.hitRangeX ? Number(queries.hitRangeX) : 50; // x座標のズレがこの値より小さければ当たり判定
var hitRangeY = queries.hitRangeY ? Number(queries.hitRangeY) : 20; // y座標のズレがこの値より小さければ当たり判定
var hitSneezeRangeX = queries.hitSneezeRangeX ? Number(queries.hitSneezeRangeX) : 200; // くしゃみをした時のx座標当たり判定（前方）
var hitSneezeRangeY = queries.hitSneezeRangeY ? Number(queries.hitSneezeRangeY) : 200; // くしゃみをした時のx座標当たり判定
// 敵キャラ設定 ///////////////////////////////
// isCorona:    true/false          コロナかどうか
// x:           200 <= x <= 3000    初期x座標 
// y:           422 <= y <= 600     初期y座標 (moveTypeが3の場合のみ反映)
// direction:   left/right          初期向き (moveTypeが3の場合のみ反映)
// speed:       0 <= speed <= 1000  スピード (300が主人公の速度, moveTypeが3の場合のみ反映)
// moveType:    0, 1, 2, 3          0: 円, 1: 斜め, 2: 上下, 3: 左右
// sneezeRate:  0 <= sneezeRate <= 10000    くしゃみをする確率（0 ~ 30 くらいが適正。1フレームあたり sneezeRate/10000 の確率でくしゃみをする。）
var enemyParameters = [
    {
        isCorona: true,
        x: 200,
        y: 450,
        direction: 'right',
        speed: 350,
        moveType: 3,
        sneezeRate: 10,
    },
    {
        isCorona: true,
        x: 250,
        y: 475,
        direction: 'right',
        speed: 300,
        moveType: 3,
        sneezeRate: 10,
    },
    {
        isCorona: true,
        x: 300,
        y: 500,
        direction: 'right',
        speed: 250,
        moveType: 3,
        sneezeRate: 10,
    },
    {
        isCorona: true,
        x: 350,
        y: 525,
        direction: 'left',
        speed: 200,
        moveType: 3,
        sneezeRate: 50,
    },
    {
        isCorona: true,
        x: 400,
        y: 550,
        direction: 'right',
        speed: 150,
        moveType: 3,
        sneezeRate: 10,
    },
    {
        isCorona: true,
        x: 450,
        y: 575,
        direction: 'left',
        speed: 100,
        moveType: 3,
        sneezeRate: 10,
    },
    {
        isCorona: true,
        x: 500,
        y: 600,
        direction: 'right',
        speed: 50,
        moveType: 3,
        sneezeRate: 10,
    },
];

////////////////////////////////////

function getRandomInt(max) {
  return Math.floor(Math.random() * Math.floor(max));
}
class TitleScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'TitleScene' });
    }

    preload ()
    {
        this.titleText = null;
        this.easyText = null;
        this.normalText = null;
        this.hardText = null;
        // this.cursors = null;
        this.pointer = null;
        this.isDismissed = false;
    }

    create ()
    {
        console.log('From TitleScene Create');
        this.isDismissed = false;
        this.titleText = this.add.text(400, 150, 'Title', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.easyText = this.add.text(400, 300, '↑： Easy', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.normalText = this.add.text(400, 400, '→： Normal', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        // this.hardText = this.add.text(400, 416, '↓： Hard', { fontSize: '32px', fill: '#000' }).setOrigin(0.5);
        // this.cursors = this.input.keyboard.createCursorKeys();

        // let spaceKey = game.input.keyboard.addKey(
        //             Phaser.Keyboard.SPACEBAR);
        // spaceKey.onDown.add(this.jump, this);     
        // Create the left/right arrow keys
        var up = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
        up.on('down', () => this.nextEasy());
        var right = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
        right.on('down', () => this.nextNormal());
        // let down = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
        // down.onDown.add(this.nextHard, this);
        // let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        // //  Phase 1: Key event.
        // //  Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object.
        // //  Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene.
        // //  Call stopPropagation to stop it reaching any other Scene.

        // spaceKey.on('down', function (key, event) {

        //     // event.stopPropagation();
        //     // event.stopImmediatePropagation();

        //     bubble1.setVisible(true);

        // });
        // this.pointer = this.input.activePointer;
        // console.log(`EasyTest ${this.easyText.x} ${this.easyText.y} ${this.easyText.displayWidth} ${this.easyText.displayHeight}`);
        // this.text = this.add.text(10, 10, 'Move the mouse', { font: '16px Courier', fill: '#00ff00' });
    }

    update () {
        this.pointer = this.input.activePointer;
        // pointerがモードを選択しているかどうか
        if (this.pointer.isDown && !this.isDismissed) {
            let x = this.pointer.x;
            let y = this.pointer.y;
            console.log(`Pointer ${this.pointer.x} ${this.pointer.y}`);
            if (Math.abs(this.easyText.x - x) < this.easyText.displayWidth / 2 && Math.abs(this.easyText.y - y) < this.easyText.displayHeight / 2) {
                this.isDismissed = true;
                this.nextEasy();
            } else if (Math.abs(this.normalText.x - x) < this.normalText.displayWidth / 2 && Math.abs(this.normalText.y - y) < this.normalText.displayHeight / 2) {
                this.isDismissed = true;
                this.nextNormal();
            }
        }

        // this.text.setText([
        //     'x: ' + this.pointer.x,
        //     'y: ' + this.pointer.y,
        //     'mid x: ' + this.pointer.midPoint.x,
        //     'mid y: ' + this.pointer.midPoint.y,
        //     'velocity x: ' + this.pointer.velocity.x,
        //     'velocity y: ' + this.pointer.velocity.y,
        //     'movementX: ' + this.pointer.movementX,
        //     'movementY: ' + this.pointer.movementY,
        //     'isDown:' + this.pointer.isDown
        // ]);
    }

    // gameMode 0: easy, 1: normal, 2: hard
    nextEasy() {
        // this.scene.stop('Title');
        this.scene.start('GameScene', {gameMode: 0});
        // this.scene.add('Result');
        // this.scene.remove('Title');
    }
    nextNormal() {
        this.scene.start('GameScene', {gameMode: 1});
    }
}

class GameScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'GameScene' });
    }

    preload ()
    {
        this.own = {};
        this.own.isEasy = false;
        this.own.enemies = {};
        this.own.move = 90 * (Math.PI / 180);
        this.own.playerHeight = 324 / 2; // scale 0.5で使う
        this.own.worldMinX = 0;
        this.own.worldMaxX = 800;
        this.own.worldMinY = 422 - this.own.playerHeight;
        this.own.worldMaxY = 600; //+ this.own.playerHeight;
        this.own.enemyInitY = (this.own.worldMaxY + this.own.worldMinY + this.own.playerHeight) / 2 ;
        this.own.worldDistanceY = this.own.worldMaxY - this.own.worldMinY - this.own.playerHeight;
        this.own.worldHalfDistanceY = 55; //this.own.worldDistanceY / 2;
        this.own.cursors = null;
        this.own.player = null;
        this.own.playerSpeed = 300;
        this.own.remainTime = 50; // 初期残り時間
        this.own.coronaPointText = null;
        this.own.remainText = null;
        this.own.coronaPoint = -1;
        this.own.pointerState = {};
        this.own.pointerState.isDowning = false;
        this.own.pointerState.startX = 0;
        this.own.pointerState.startY = 0;
        this.own.debug = true; // DEBUG MODE
        this.isDismissed = false;
        this.isReady = false;
        // this.load.image('face', 'assets/pics/bw-face.png');
    }

    create (data)
    {
        this.events.once("shutdown", () => this.shutdown());
        console.log('From GameScene Create');
        // TODO DEBUG
        if(this.own.debug) window.console.log('現在のゲームモード: ' + data.gameMode);
        // this.own.isEasy = (data.gameMode === 0);

        // this.cameras.main.setBounds(0, 0, 800 * 4, 600);
        // // this.physics.world.setBounds(worldMinX, worldMinY, worldMaxX, worldMaxY);
        // this.physics.world.setBounds(this.own.worldMinX, this.own.worldMinY, this.own.worldMaxX * 4, this.own.worldMaxY - this.own.worldMinY);
        // this.cameras.main.setDeadzone(100, 20);
        // // this.cameras.main.setZoom(1.3);

        // let background = this.add.sprite(0, 0, 'cityscene', 'background.png');
        // this.add.sprite(800, 0, 'cityscene', 'background.png');
        // this.add.sprite(1600, 0, 'cityscene', 'background.png');
        // this.add.sprite(2400, 0, 'cityscene', 'background.png');

        // this.own.player = this.physics.add.sprite(0, 450, 'cityscene', 'capguy/walk/0001.png');
        // this.own.player.setScale(0.5, 0.5);
        // this.own.player.setCollideWorldBounds(true);
        // this.cameras.main.startFollow(this.own.player, true);

        // // 敵の初期配置
        // for (var i = 0; i < enemyParameters.length; i++) {
        //     let enemyInitX = enemyParameters[i].x; //1600 + (getRandomInt(57) - 28) * 25;
        //     // var randomEnemyInitY = this.own.enemyInitY + getRandomInt(this.own.worldDistanceY) - this.own.worldHalfDistanceY;
        //     let enemyInitY = enemyParameters[i].y;
        //     if (enemyParameters[i].moveType < 3) enemyInitY = this.own.enemyInitY; //this.own.worldMinY + this.own.playerHeight;
        //     this.own.enemies[i] = this.physics.add.sprite(enemyInitX, enemyInitY, 'cityscene', 'enemy/walk/0001.png');
        //     this.own.enemies[i].own = {};
        //     this.own.enemies[i].own.speed = enemyParameters[i].speed;
        //     this.own.enemies[i].own.moveType = enemyParameters[i].moveType;
        //     this.own.enemies[i].own.enemyInitX = enemyInitX;
        //     this.own.enemies[i].own.isCorona = enemyParameters[i].isCorona;
        //     if (this.isEasy && this.own.enemies[i].own.isCorona) this.own.enemies[i].setTint('#000');
        //     this.own.enemies[i].own.isInfected = false;
        //     this.own.enemies[i].own.sneezeRate = enemyParameters[i].sneezeRate;
        //     this.own.enemies[i].own.sneezeRemainTime = 0;
        //     this.own.enemies[i].setScale(0.5, 0.5);
        //     this.own.enemies[i].flipX = enemyParameters[i].direction === 'left';
        // }

        // var walkframeNames = this.anims.generateFrameNames('cityscene', {
        //     start: 1, end: 8, zeroPad: 4,
        //     prefix: 'capguy/walk/', suffix: '.png'
        // });
        // this.anims.create({ key: 'walk', frames: walkframeNames, frameRate: 10, repeat: -1 });
        // var stayframeNames = this.anims.generateFrameNames('cityscene', {
        //     start: 4, end: 4, zeroPad: 4,
        //     prefix: 'capguy/walk/', suffix: '.png'
        // });
        // this.anims.create({ key: 'stay', frames: stayframeNames, frameRate: 10, repeat: -1 });
        // var enemyWalkframeNames = this.anims.generateFrameNames('cityscene', {
        //     start: 1, end: 8, zeroPad: 4,
        //     prefix: 'enemy/walk/', suffix: '.png'
        // });
        // this.anims.create({ key: 'enemyWalk', frames: enemyWalkframeNames, frameRate: 10, repeat: -1 });
        // var enemyStayframeNames = this.anims.generateFrameNames('cityscene', {
        //     start: 4, end: 4, zeroPad: 4,
        //     prefix: 'enemy/walk/', suffix: '.png'
        // });
        // this.anims.create({ key: 'enemyStay', frames: enemyStayframeNames, frameRate: 10, repeat: -1 });

        // this.own.cursors = this.input.keyboard.createCursorKeys();
        // テキスト配置
        if (this.own.debug) {
            this.own.coronaPointText = this.add.text(32, 32).setScrollFactor(0).setFontSize(32).setColor('#000000');
            this.own.coronaPointText.setText('CoronaPoint: ' + this.own.coronaPoint);
        }
        this.own.remainText = this.add.text(600, 32).setScrollFactor(0).setFontSize(32).setColor('#000000');
        this.own.remainText.setText('Time: ' + this.own.remainTime);
        this.isReady = true;
    }

    update () {
        console.log('From GameScene Update');
        // if (!this.isReady) return;
        // // スワイプの動き（スマホ用）
        // let pointer = this.input.activePointer;
        // if (pointer.isDown && !this.own.pointerState.isDowning) {
        //     this.own.pointerState.isDowning = true;
        //     this.own.pointerState.startX = pointer.x;
        //     this.own.pointerState.startY = pointer.y;
        // }
        // if (!pointer.isDown) this.own.pointerState.isDowning = false;
        // let isLeftDown = pointer.isDown && pointer.x < this.own.pointerState.startX - 50;
        // let isRightDown = pointer.isDown && pointer.x > this.own.pointerState.startX + 50;
        // let isUpDown = pointer.isDown && pointer.y < this.own.pointerState.startY - 50;
        // let isDownDown = pointer.isDown && pointer.y > this.own.pointerState.startY + 50;

        // this.own.player.setVelocity(0);
        // // カーソル
        // if (this.own.cursors.left.isDown || isLeftDown)
        // {
        //     this.own.player.setVelocityX(-this.own.playerSpeed);
        //     this.own.player.flipX = true;
        //     // this.own.player.anims.play('walk', true);
        // }
        // if (this.own.cursors.right.isDown || isRightDown)
        // {
        //     this.own.player.setVelocityX(this.own.playerSpeed);
        //     this.own.player.flipX = false;
        //     // this.own.player.anims.play('walk', true);
        // }
        // if (this.own.cursors.up.isDown || isUpDown)
        // {
        //     this.own.player.setVelocityY(-this.own.playerSpeed);
        //     // this.own.player.anims.play('walk', true);
        // }
        // if (this.own.cursors.down.isDown || isDownDown)
        // {
        //     this.own.player.setVelocityY(this.own.playerSpeed);
        //     // this.own.player.anims.play('walk', true);
        // }
        // if ((!this.own.cursors.left.isDown && !this.own.cursors.right.isDown && !this.own.cursors.up.isDown && !this.own.cursors.down.isDown) && !(isLeftDown || isRightDown || isUpDown || isDownDown)) {
        //     this.own.player.anims.play('stay', true);
        // } else {
        //     this.own.player.anims.play('walk', true);
        // }

        // // depth sorting
        // this.own.player.depth = this.own.player.y;

        // // enemy
        // for (var i = 0; i < enemyParameters.length; i++) {
        //     this.own.enemies[i].setVelocity(0);
        //     if (this.own.enemies[i].own.sneezeRemainTime <= 0) { // 敵キャラくしゃみ中は動かない
        //         switch (this.own.enemies[i].own.moveType) {
        //         case 0:
        //             this.own.enemies[i].setVelocityX(Math.cos(this.own.move) * this.own.worldHalfDistanceY);
        //             // this.own.enemies[i].x = this.own.enemyInitY + Math.cos(this.own.move) * this.own.worldHalfDistanceY;
        //             this.own.enemies[i].setVelocityY(Math.sin(this.own.move) * this.own.worldHalfDistanceY);
        //             // console.log(Math.sin(this.own.move))
        //             // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.sin(this.own.move) * this.own.worldHalfDistanceY;
        //             break;
        //         case 1:
        //             this.own.enemies[i].setVelocityX(Math.sin(-this.own.move) * this.own.worldHalfDistanceY);
        //             // this.own.enemies[i].x = this.own.enemyInitY + Math.sin(-this.own.move) * this.own.worldHalfDistanceY;
        //             this.own.enemies[i].setVelocityY(Math.cos(-this.own.move) * this.own.worldHalfDistanceY);
        //             // console.log(Math.cos(-this.own.move))
        //             // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.cos(-this.own.move) * this.own.worldHalfDistanceY;
        //         case 2:
        //             this.own.enemies[i].setVelocityY(Math.sin(this.own.move) * (this.own.worldHalfDistanceY));
        //             // this.own.enemies[i].y = this.own.enemies[i].own.enemyInitX + Math.sin(this.own.move) * (this.own.worldHalfDistanceY - 20);
        //             break;
        //         case 3:
        //             if (this.own.enemies[i].flipX) {
        //                 // 左向き
        //                 if (this.own.enemies[i].x > 200) {
        //                     this.own.enemies[i].setVelocityX(-this.own.enemies[i].own.speed);
        //                 } else {
        //                     this.own.enemies[i].setVelocityX(this.own.enemies[i].own.speed);
        //                 }
        //             } else {
        //                 // 右向き
        //                 if (this.own.enemies[i].x < 3000) {
        //                     this.own.enemies[i].setVelocityX(this.own.enemies[i].own.speed);
        //                 } else {
        //                     this.own.enemies[i].setVelocityX(-this.own.enemies[i].own.speed);
        //                 }
        //             }
        //             break;
        //         default:
        //             console.log('Sorry, we are out of ' + i + '.');
        //         }

        //         // 敵キャラ振り向き判定
        //         if (this.own.enemies[i].body.velocity.x > 0) {
        //             this.own.enemies[i].flipX = false
        //         } else if (this.own.enemies[i].body.velocity.x < 0) {
        //             this.own.enemies[i].flipX = true
        //         }
        //         // 敵キャラアニメーション
        //         if (this.own.enemies[i].body.velocity.x === 0 && this.own.enemies[i].body.velocity.y === 0) {
        //             this.own.enemies[i].anims.play('enemyStay', true);
        //         } else {
        //             this.own.enemies[i].anims.play('enemyWalk', true);
        //         }
        //         // 敵キャラdepth更新
        //         this.own.enemies[i].depth = this.own.enemies[i].y;
        //     }

        //     // playerとの当たり判定
        //     if (this.own.enemies[i].own.isCorona) {
        //         // 敵キャラ当たり判定
        //         if (!this.own.enemies[i].own.isInfected && Math.abs(this.own.enemies[i].x - this.own.player.x) <= hitRangeX && Math.abs(this.own.enemies[i].y - this.own.player.y) <= hitRangeY) {
        //             this.own.enemies[i].own.isInfected = true;
        //             // this.own.enemies[i].setTint('#000');
        //             this.own.coronaPoint += 1;
        //         }
        //         // 敵キャラくしゃみ当たり判定
        //         if (this.own.enemies[i].own.sneezeRemainTime > 0) {
        //             // console.log(`Pothis.own.enemies[i] ${i} ${this.own.enemies[i].own.sneezeRemainTime} ${this.own.enemies[i].x} ${this.own.enemies[i].y} ${this.own.enemies[i].own.sneezeRange.x} ${this.own.enemies[i].own.sneezeRange.y}`)
        //             this.own.enemies[i].own.sneezeRemainTime -= 1;
        //             if (this.own.enemies[i].own.sneezeRange) {
        //                 if (!this.own.enemies[i].own.isInfected && this.own.enemies[i].own.sneezeRange.x <= this.own.player.x && this.own.player.x <= this.own.enemies[i].own.sneezeRange.x + this.own.enemies[i].own.sneezeRange.width && this.own.enemies[i].own.sneezeRange.y <= this.own.player.y && this.own.player.y <= this.own.enemies[i].own.sneezeRange.y + this.own.enemies[i].own.sneezeRange.height) {
        //                     this.own.enemies[i].own.isInfected = true;
        //                     // this.own.enemies[i].setTint('#000');
        //                     this.own.coronaPoint += 1;
        //                 }
        //             }
        //             // くしゃみ時間がなくなったのでくしゃみ消す
        //             if (this.own.enemies[i].own.sneezeRemainTime <= 0) {
        //                 if (this.own.enemies[i].own.sneezeRange) {
        //                     this.own.enemies[i].own.sneezeRange.destroy();
        //                     this.own.enemies[i].own.sneezeRange = null;
        //                 }
        //             }
        //         }
        //         // 敵キャラがくしゃみをしていない時にランダムで行う
        //         if (this.own.enemies[i].own.sneezeRemainTime <= 0 && getRandomInt(10000) < this.own.enemies[i].own.sneezeRate) {
        //             this.own.enemies[i].own.sneezeRemainTime = 100;
        //             this.own.enemies[i].own.sneezeRange = this.add.rectangle(
        //                 this.own.enemies[i].flipX ? (this.own.enemies[i].x) - hitSneezeRangeX : this.own.enemies[i].x,
        //                 this.own.enemies[i].y - hitSneezeRangeY / 2, 
        //                 hitSneezeRangeX, 
        //                 hitSneezeRangeY, 
        //                 0x6666ff
        //             ).setAlpha(0.5).setOrigin(0);
        //         }
        //     }
        // }

        // デバッグテキスト
        if (this.own.debug) {
            this.own.coronaPointText.setText('CoronaPoint: ' + this.own.coronaPoint);
        }
        this.own.remainTime -= 1;
        this.own.remainText.setText('Time: ' + this.own.remainTime);
        this.own.move += 0.01;

        // 残り時間判定
        if (this.own.remainTime <= 0 && !this.isDismissed) {
            this.isDismissed = true;
            this.physics.pause();
            this.isReady = false;
            this.scene.start('ResultScene', {coronaPoint: this.own.coronaPoint});
        }
    }

    shutdown() {
        console.log('From GameScene shutdown');
        // this.loaded.reset();
        this.game.anims.removeAllListeners();
    }
}

class ResultScene extends Phaser.Scene {
    constructor ()
    {
        super({ key: 'ResultScene' });
    }

    preload ()
    {
        this.laterText = null;
        this.laterRemainTime = 150;
        this.laterBackground = null;
        this.resultText = null;
        this.retryText = null;
        this.coronaPoint = 0;
        this.isOpened = false;
        this.cursors = null;
        this.isDismissed = false;
    }

    create (data)
    {
        console.log('From ResultScene Create');
        this.coronaPoint = data.coronaPoint;
        if (this.coronaPoint < 0) {
            this.resultText = this.add.text(400, 150, 'Happy end!!!', { fontSize: '72px', fill: '#fff' }).setOrigin(0.5);
        } else {
            this.resultText = this.add.text(400, 150, 'Bad end・・・', { fontSize: '72px', fill: '#fff' }).setOrigin(0.5);
        }
        this.retryText = this.add.text(400, 400, '→： Retry', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.laterBackground = this.add.rectangle(0, 0, 800, 600, 0x000000).setOrigin(0);
        this.laterText = this.add.text(400, 150, '10 days later・・・', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
        this.cursors = this.input.keyboard.createCursorKeys();
    }

    update () {
        if (this.isDismissed) return;
        if (!this.isOpened) {
            this.laterRemainTime -= 1;

            if (this.laterRemainTime <= 0) {
                this.isOpened = true;
                this.laterText.destroy();
                this.laterBackground.destroy();
            }
        } else {
            if (this.cursors.right.isDown)
            {
                this.nextTitle();
            }
            // スワイプの動き（スマホ用）
            let pointer = this.input.activePointer;
            if (pointer.isDown) {
                let x = pointer.x;
                let y = pointer.y;
                if (!this.isDismissed && Math.abs(this.retryText.x - x) < this.retryText.displayWidth / 2 && Math.abs(this.retryText.y - y) < this.retryText.displayHeight / 2) {
                    this.isDismissed = true;
                    this.nextTitle();
                }
            }
        }
    }

    nextTitle () {
        // this.scene.stop('Result');
        // this.scene.remove('Result');
        // this.scene.add('Title', new TitleScene(), true);
        this.scene.start('sceneA');
        // this.scene.add('Game');
    }
}

class SceneA extends Phaser.Scene {

constructor ()
{
    super({ key: 'sceneA' });
}

preload ()
{
    this.load.image('face', 'assets/pics/bw-face.png');
    this.load.multiatlas('cityscene', 'assets/cityscene.json', 'assets');
}

create ()
{
    console.log('From SceneA Create');

    this.face = this.add.image(400, 300, 'face');

    this.input.manager.enabled = true;

    this.input.once('pointerdown', function () {

        this.scene.start('sceneB');

    }, this);
}

}

class SceneB extends Phaser.Scene {

constructor ()
{
    super({ key: 'sceneB' });
}

preload ()
{
    this.load.image('arrow', 'assets/sprites/longarrow.png');
}

create ()
{
    console.log('From SceneB Create');

    this.arrow = this.add.sprite(400, 300, 'arrow').setOrigin(0, 0.5);

    this.input.once('pointerdown', function (event) {

        this.scene.start('sceneC');

    }, this);
}

update ()
{
    this.arrow.rotation += 0.01;
}

}

class SceneC extends Phaser.Scene {

constructor ()
{
    super({ key: 'sceneC' });
}

preload ()
{
    this.load.image('mech', 'assets/pics/titan-mech.png');
}

create ()
{
    console.log('From SceneC Create');

    this.add.sprite(Phaser.Math.Between(300, 600), 300, 'mech');

    this.input.once('pointerdown', function (event) {

        this.scene.start('TitleScene');

    }, this);
}

}

var config = {
type: Phaser.AUTO,
width: 800,
height: 600,
backgroundColor: '#000000',
parent: 'phaser-example',
physics: {
            default: 'arcade',
            arcade: {
                // gravity: { y: 300 },
                debug: false
            }
        },
scene: [ SceneA, SceneB, SceneC, TitleScene, GameScene, ResultScene ]
};

var game = new Phaser.Game(config);

</script>

</body>
</html>